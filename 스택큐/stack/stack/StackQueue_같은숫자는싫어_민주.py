arr = [1,1,3,3,0,1,1,1]

## 앞뒤가 같은 숫자면 제거하는 코드라고 생각
## for문으로 하나씩 돌리면 되겠다고 생각함. 

def sol(arr):
    nums = 0
    for i in arr:
        if arr[i] == arr[i+1]:
            arr.pop(i+1)
    return arr

## 사용자가 작성한 코드에는 몇 가지 문제가 있습니다. 
## 먼저, `for` 문에서 `arr[i]`를 사용하고 있는데, `i`는 `arr`의 값이 아니라 인덱스처럼 사용되고 있습니다. 
## 이는 리스트의 방식을 잘못 이해한 것으로, `for i in arr`는 `i`가 `arr`의 요소가 되므로 `arr[i]`는 올바르지 않은 접근법입니다.
## 또한, `arr.pop(i+1)`을 사용하여 요소를 제거하고 있는데, 이 방식은 인덱스를 사용하는 동안 리스트의 길이가 변하기 때문에 예상치 못한 인덱스 오류를 발생시킬 수 있습니다. 
## 즉, 요소를 제거하면 다음 요소의 인덱스가 이동하기 때문에 `i + 1`을 접근할 수 없게 됩니다. 
## 이 문제를 해결하기 위해, 중복된 숫자를 제거할 때 기존의 요소를 체크하고 유지하는 방법을 생각해 보세요. 
## 또한, 리스트의 순서를 유지하면서 새로운 리스트를 만들어 나가는 방식을 사용해 보길 권장합니다. 

## 연속된 중복을 없애는 것 -> 인덱스를 쓰지 말고 실제 value로 진행해보자. 
## num1을 지금값, num2를 이전값으로 해서 둘을 비교함.
## 비교해서 같으면 안넣고, 같으면 넣는 식으로
## 이후에 num2값은 계속 갱신해주기 

def solution(arr):
    answer = []
    num2 = None
    for num1 in arr:
        if num1 != num2:
            answer.append(num1)
        num2 = num1
    return answer

print(solution(arr))
